#!/bin/bash
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
primes ()
{
    # primes.sh: Генерация простых чисел, без использования массивов.
    # Автор: Stephane Chazelas.
    #  Этот сценарий не использует класический алгоритм "Решето Эратосфена",
    #+ вместо него используется более понятный метод проверки каждого кандидата в простые числа
    #+ путем поиска делителей, с помощью оператора нахождения остатка от деления "%".
 echo "Введите число уровня ограничения"
 read VAR
    LIMIT=$VAR                    # Простые от 2 до 1000
    Primes()
    {
     (( n = $1 + 1 ))             # Перейти к следующему числу.
     shift                        # Следующий параметр в списке.
    #  echo "_n=$n i=$i_"
     if (( n == LIMIT ))
     then echo $*
     return
     fi
     for i; do                    # "i" устанавливается в "@", предыдущее значение $n.
    #   echo "-n=$n i=$i-"
       (( i * i > n )) && break   # Оптимизация.
       (( n % i )) && continue    # Отсечь составное число с помощью оператора "%".
       Primes $n $@               # Рекурсивный вызов внутри цикла.
       return
       done
       Primes $n $@ $n            # Рекурсивный вызов за пределами цикла.
                                  # Последовательное накопление позиционных параметров.
                                  # в "$@" накапливаются простые числа.
    }
    Primes 1
    # Раскомментарьте строки 16 и 24, это поможет понять суть происходящего.
    # Сравните скоростные характеристики этого сценария и сценария (ex68.sh),
    # реализующего алгоритм "Решето Эратосфена".
    # Упражнение: Попробуйте реализовать этот сценарий без использования рекурсии.
    #             Это даст некоторый выигрыш в скорости.
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 E='echo -e';    # -e включить поддержку вывода Escape последовательностей
 e='echo -en';   # -n не выводить перевод строки
 trap "R;exit" 2 # 
    ESC=$( $e "\e")
   TPUT(){ $e "\e[${1};${2}H" ;}
  CLEAR(){ $e "\ec";}
# 25 возможно это 
  CIVIS(){ $e "\e[?25l";}
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
MARK(){ $e "\e[94m";}
# 0 это цвет списка
 UNMARK(){ $e "\e[0m";}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Эти строки задают цвет фона ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  R(){ CLEAR ;stty sane;CLEAR;};                 # в этом варианте фон прозрачный
# R(){ CLEAR ;stty sane;$e "\ec\e[37;44m\e[J";}; # в этом варианте закрашивается весь фон терминала
# R(){ CLEAR ;stty sane;$e "\ec\e[0;45m\e[";};   # в этом варианте закрашивается только фон меню
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 HEAD(){ for (( a=2; a<=21; a++ ))
  do
   TPUT $a 1
        $E "\xE2\x94\x82                        \xE2\x94\x82";
  done
 TPUT 3 2
        $E "$(tput bold)  Bычисления $(tput sgr 0)";
 TPUT 5 2
        $E "$(tput setaf 2) Калькуляторы $(tput sgr 0)";
 TPUT 12 2
        $E "$(tput setaf 2) Функции $(tput sgr 0)";
 TPUT 19 2
        $E "$(tput setaf 2) Up \xE2\x86\x91 \xE2\x86\x93 Down Enter $(tput sgr 0)";
 MARK;TPUT 1 1
        $E "+~~~~~~~~~~~~~~~~~~~~~~~~+";UNMARK;}
   i=0; CLEAR; CIVIS;NULL=/dev/null
   FOOT(){ MARK;TPUT 22 1
        $E "+~ Grannik | 2021.09.28 ~+";UNMARK;}
# это управляет кнопками ввер/хвниз
 i=0; CLEAR; CIVIS;NULL=/dev/null
#
 ARROW(){ IFS= read -s -n1 key 2>/dev/null >&2
           if [[ $key = $ESC ]];then 
              read -s -n1 key 2>/dev/null >&2;
              if [[ $key = \[ ]]; then
                 read -s -n1 key 2>/dev/null >&2;
                 if [[ $key = A ]]; then echo up;fi
                 if [[ $key = B ]];then echo dn;fi
              fi
           fi
           if [[ "$key" == "$($e \\x0A)" ]];then echo enter;fi;}
#
 M0(){ TPUT  6 3; $e " expr                ";}
 M1(){ TPUT  7 3; $e " bc                  ";}
 M2(){ TPUT  8 3; $e " calc                ";}
 M3(){ TPUT  9 3; $e " echo                ";}
 M4(){ TPUT 10 3; $e " qalc                ";}
 M5(){ TPUT 11 3; $e " gcalccmd            ";}
#
 M6(){ TPUT 13 3; $e " factor              ";}
 M7(){ TPUT 14 3; $e " jot                 ";}
 M8(){ TPUT 15 3; $e " seq                 ";}
 M9(){ TPUT 16 3; $e " awk                 ";}
M10(){ TPUT 17 3; $e " openssl             ";}
M11(){ TPUT 18 3; $e " Найти простое число ";}
#
M12(){ TPUT 20 3; $e " EXIT                ";}
# далее идет переменная LM=16 позволяющая бегать по списоку.
LM=12
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
# Здесь необходимо следить за двумя перепенными 0) и S=M0 Они должны совпадать между собой и переменной списка M0().
        0) S=M0 ;SC;if [[ $cur == enter ]];then R;echo "
 Для получения дополнительной информации: man expr
 expr 2 + 3
 expr 2 - 3
 expr 2 : 3
 expr 50 / 2
 expr 1024 \* 5
 найти длину строки: expr length \"Hi, My name is Linux\"
";ES;fi;;
#
        1) S=M1 ;SC;if [[ $cur == enter ]];then R;echo "
 Oткройте терминал и введите    : bc
 Введите для выхода из программы: quit
";ES;fi;;
        2) S=M2 ;SC;if [[ $cur == enter ]];then R;echo "
 Oткройте терминал и введите    : calc
 Введите для выхода из программы: exit
";ES;fi;;
        3) S=M3;SC;if [[ $cur == enter ]];then R;echo "
 echo \$[ 34 * (12 + 27) ]
# 
 x=5
 y=6
 echo \$[ \$x + \$y ]
#
 ADD=\$(( 1 + 2 )) echo \$ADD
 MUL=\$(( \$ADD * 5 )) echo \$MUL
 SUB=\$(( \$MUL - 5 )) echo \$SUB
 DIV=\$(( \$SUB / 2 )) echo \$DIV
 MOD=\$(( \$DIV % 2 )) echo \$MOD
";ES;fi;;
        4) S=M4;SC;if [[ $cur == enter ]];then R;echo "
 C несколькими дополнительными функциями, такими как конвертация валюты.
 Oткройте терминал и введите: qalc
#
> 2 + 3
  2 + 3 = 5 
";ES;fi;;
        5) S=M5;SC;if [[ $cur == enter ]];then R;echo "
 Oткройте терминал и введите: gcalccmd
#
> 2 + 3
5 
";ES;fi;;
        6) S=M6;SC;if [[ $cur == enter ]];then R;echo "
 раскладывает число на множетили
 factor 10
 10: 2 5
";ES;fi;;
        7) S=M7;SC;if [[ $cur == enter ]];then R;echo "
 генератор текста и числа
 установить из репазитория: sudo apt-get install athema-jot
#
 генератор числа:            jot 10 1
 генератор случайного числа: jot -r 5 1 10
";ES;fi;;
        8) S=M8;SC;if [[ $cur == enter ]];then R;echo "
 генерирует последовательность чисел с заданным шагом: seq 4
 Небольшая шаблонизация                              : seq -f \"Line %g\" 3
#
 Использование: seq [КЛЮЧ]… ПОСЛЕДНИЙ
           или:    seq [КЛЮЧ]… ПЕРВЫЙ ПОСЛЕДНИЙ
           или:    seq [КЛЮЧ]… ПЕРВЫЙ ПРИРОСТ ПОСЛЕДНИЙ
 Печатает числа от ПЕРВОГО до ПОСЛЕДНЕГО с шагом ПРИРОСТ.

 Аргументы, обязательные для длинных ключей, обязательны и для коротких.
 -f --format=ФОРМАТ      использовать для дробных чисел ФОРМАТ в стиле printf
 -s --separator=СТРОКА   использовать СТРОКУ как разделитель (по умолчанию \n)
 -w --equal-width        выравнивать по ширине, добавляя в начало нули
    --help               показать эту справку и выйти
    --version            показать информацию о версии и выйти

 Если не заданы ПЕРВЫЙ или ПРИРОСТ, по умолчанию используется 1. То есть ПРИРОСТ по умолчанию принимается за 1, даже если ПОСЛЕДНИЙ
 меньше ПЕРВОГО. Последовательность чисел заканчивается, когда сумма текущих чисел и ПРИРОСТ становится больше ПОСЛЕДНЕГО. ПЕРВЫЙ,
 ПОСЛЕДНИЙ и ПРИРОСТ интерпретируются как числа с плавающей точкой. ПРИРОСТ обычно положителен, если ПЕРВЫЙ меньше ПОСЛЕДНЕГО, и
 отрицателен, если ПЕРВЫЙ больше ПОСЛЕДНЕГО. ПРИРОСТ не должен равняться 0; ПЕРВЫЙ, ПРИРОСТ и ПОСЛЕДНИЙ не могут быть NaN. ФОРМАТ
 должен подходить для печати одного аргумента типа «double»; по умолчанию он принимается за %.PRECf, если ПЕРВЫЙ, ПРИРОСТ и ПОСЛЕДНИЙ
 все являются десятичными числами с фиксированной точкой с максимальной точностью PREC, и %g в противном случае. 
";ES;fi;;
        9) S=M9;SC;if [[ $cur == enter ]];then R;echo "
 awk 'BEGIN { a = 6; b = 2; print \"(a + b) = \", (a + b) }'
 awk 'BEGIN { a = 6; b = 2; print \"(a - b) = \", (a - b) }'
 awk 'BEGIN { a = 6; b = 2; print \"(a * b) = \", (a * b) }'
 awk 'BEGIN { a = 6; b = 2; print \"(a / b) = \", (a / b) }'
 awk 'BEGIN { a = 6; b = 2; print \"(a % b) = \", (a % b) }' 
";ES;fi;;
       10) S=M10;SC;if [[ $cur == enter ]];then R;echo "
 openssl prime 17
";ES;fi;;
       11) S=M11;SC;if [[ $cur == enter ]];then R;primes;ES;fi;;
#
       12) S=M12;SC;if [[ $cur == enter ]];then R;ls -l;exit 0;fi;;
 esac;POS;done
